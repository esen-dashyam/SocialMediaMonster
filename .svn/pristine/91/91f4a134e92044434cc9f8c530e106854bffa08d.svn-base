using Microsoft.AspNet.Identity.Owin; using Microsoft.AspNet.Identity; using SocialMonster.Models; using System.Net; using System.Net.Http; using System.Web.Http; using WEBAPIJWT.Auth; using SocialMonster.DAL; using Microsoft.AspNetCore.Cryptography.KeyDerivation; using System.Security.Cryptography; using System; using System.Linq; using System.IO; using System.Text;  namespace WEBAPIJWT.Controllers {     public class TokenController : System.Web.Http.ApiController     {         [HttpPost]         [AllowAnonymous]         public IHttpActionResult Get(string username, string password)         {             var result = (CheckUserAsync(username, password));             if (result.status.Equals("succeed"))             {                  return Ok(                 new                 {                     userID=result.userID,                     email=result.email,                     token = JwtAuthManager.GenerateJWTToken(username,1),                     expireTime ="1440 minuts",                     errorCode=result.error,                     status = result.status                 });             }             else             {                 return Ok(                     new                     {                         userID = result.userID,                         email = result.email,                         token = "",                         expireTime = "0 minuts",                         error = result.error,                         status = result.status                     }                     );             }         }         public CheckStatus CheckUserAsync(string username, string password)         {             CheckStatus result = new CheckStatus();              MonitoringEntities monitoringDB = new MonitoringEntities();             var user = (from u in monitoringDB.AspNetUsers                          where u.UserName==username                          select u).FirstOrDefault();              if (user is null)             {                 result.error = "User Not Found";                 result.status = "failed";             }             else             {                 string passwordHash = user.PasswordHash;                 try                 {                    // string decPassword = Decrypt(password);                     PasswordHasher passwordHasher = new PasswordHasher();                     var passwordResult = passwordHasher.VerifyHashedPassword(passwordHash, password);                     if (passwordResult.Equals(PasswordVerificationResult.Success))                     {                         if (user.EmailConfirmed == true)                         {                             result.userID = user.Id;                             result.email = user.Email;                             result.error = "";                             result.status = "succeed";                         }                         else                         {                             result.error = "account not confirmed";                             result.status = "failed";                         }                     }                     else                     {                         result.error = "username or password is incorrect";                         result.status = "failed";                     }                 }                 catch                 {                     return result;                 }             }             return result;         }          public struct CheckStatus         {             public string userID;             public string email;             public string error;             public string status;             public string token;         }          public string Decrypt(string textToDecrypt)         {             try             {                 string ToReturn = "";                 string publickey = "2F46A576E5A7234753778214125442A472D4A614E645267556B5870327335";                  string privatekey = "13344678";                 byte[] privatekeyByte = { };                 privatekeyByte = System.Text.Encoding.UTF8.GetBytes(privatekey);                 byte[] publickeybyte = { };                 publickeybyte = System.Text.Encoding.UTF8.GetBytes(publickey);                 MemoryStream ms = null;                 CryptoStream cs = null;                 byte[] inputbyteArray = new byte[textToDecrypt.Replace(" ", "+").Length];                 inputbyteArray = Convert.FromBase64String(textToDecrypt.Replace(" ", "+"));                 using (DESCryptoServiceProvider des = new DESCryptoServiceProvider())                 {                     ms = new MemoryStream();                     cs = new CryptoStream(ms, des.CreateDecryptor(publickeybyte, privatekeyByte), CryptoStreamMode.Write);                     cs.Write(inputbyteArray, 0, inputbyteArray.Length);                     cs.FlushFinalBlock();                     Encoding encoding = Encoding.UTF8;                     ToReturn = encoding.GetString(ms.ToArray());                 }                 return ToReturn;             }             catch (Exception ae)             {                 throw new Exception(ae.Message, ae.InnerException);             }         }      } } 